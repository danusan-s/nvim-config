{
    "DijkstraAlgorithm": {
        "prefix": "dijkstra",
        "body": [
            "void dijkstra(int source, int dest, vector<vector<int>>& adjList, vector<int>& dist) {",
            "    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;",
            "    dist[source] = 0;",
            "    pq.push({0, source});",
            "",
            "    while (!pq.empty()) {",
            "        int u = pq.top().second;",
            "        int u_dist = pq.top().first;",
            "        if (u == dest) return;",
            "        pq.pop();",
            "",
            "        for (auto& neighbor : adjList[u]) {",
            "            int v = neighbor.first;",
            "            int weight = neighbor.second;",
            "",
            "            if (u_dist + weight < dist[v]) {",
            "                dist[v] = u_dist + weight;",
            "                pq.push({dist[v], v});",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Dijkstra's algorithm to find the shortest path from a source vertex to all other vertices",
        "scope": "cpp",
    },
    "UnionFindAlgorithm": {
        "prefix": "unionfind",
        "body": [
            "class UnionFind {",
            "private:",
            "    vector<int> parent, rank;",
            "public:",
            "    UnionFind(int n) {",
            "        parent.resize(n);",
            "        rank.resize(n, 0);",
            "        for (int i = 0; i < n; ++i) {",
            "            parent[i] = i;",
            "        }",
            "    }",
            "",
            "    int find(int u) {",
            "        if (u != parent[u]) {",
            "            parent[u] = find(parent[u]);",
            "        }",
            "        return parent[u];",
            "    }",
            "",
            "    void unionSets(int u, int v) {",
            "        int rootU = find(u);",
            "        int rootV = find(v);",
            "        if (rootU != rootV) {",
            "            if (rank[rootU] > rank[rootV]) {",
            "                parent[rootV] = rootU;",
            "            } else if (rank[rootU] < rank[rootV]) {",
            "                parent[rootU] = rootV;",
            "            } else {",
            "                parent[rootV] = rootU;",
            "                rank[rootU]++;",
            "            }",
            "        }",
            "    }",
            "};"
        ],
        "description": "Union-Find (Disjoint Set Union) algorithm with path compression and union by rank",
        "scope": "cpp",
    },
}

